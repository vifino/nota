#!/usr/bin/env carbon

-- nota
-- A modular applet platform designed for TODO lists and the like.
-- Due to the modular design, most of the things will be away from this file, however, the basics, like the module loading and storage are defined here.

-- Variables and their defaults
local nota_version = "v0.0.1"
local module_frontend = "plain"
local applet = "list"

-- Autogenerated variables, do not touch.
local nota_build_date = os.clock()
local nota_git_info = "RUNFROMSOURCE"

-- Option parsing
-- Taken from http://lua-users.org/wiki/PosixGetOpt but modified a little.
function getopt(args, optstring)
	local opts = { }

	for optc, optv in optstring:gmatch("(%a)(:?)") do
		opts[optc] = {
			hasarg = optv == ":"
		}
	end

	local has_colon = optstring:sub(1, 1) == ":"

	return coroutine.wrap(function()
		local yield = coroutine.yield
		local i = 1

		while i <= #args do
			local arg = args[i]

			i = i + 1

			if arg == "--" then
				break
			elseif arg:sub(1, 1) == "-" then
				for j = 2, #arg do
					local opt = arg:sub(j, j)

					if opts[opt] then
						if opts[opt].hasarg then
							if j == #arg then
								if args[i] then
									yield(opt, args[i])
									i = i + 1
								elseif has_colon then
									yield(':', opt)
								else
									yield('?', opt)
								end
							else
								yield(opt, arg:sub(j + 1))
							end

							break
						else
							yield(opt, false)
						end
					else
						yield('?', opt)
					end
				end
			else
				yield(false, arg)
			end
		end

		for i = i, #args do
			yield(false, args[i])
		end
	end)
end
-- End of code from the Lua Users Wiki.

-- Run the option parser
local nota_args = {}
local nota_argsn = 1

local nota_usage = [[
Usage: nota [-h] [-f <frontend>] <applet name> <applet args..>

Options:
  -h:
    Show this help.
  -v:
   Display version.
  -f <frontend>:
    Choose frontend used to display applet's output.
]]
for opt, arg in getopt(arg, ":hvf:") do
	if opt == "?" or opt == ":" or opt == "h" then -- unknown option, missing option or just plain help display
		if opt == "?" then
			print("Unknown option: "..arg)
			print()
		elseif opt == ":" then
			print("Missing option: "..arg)
			print()
		end
		print(nota_usage)
		os.exit(1)
	elseif opt == false then -- not an option
		nota_args[nota_argsn] = arg
		nota_argsn = nota_argsn + 1
	else -- option
		if opt == "v" then -- display version
			print("nota version: "..nota_version)
			print("Build date: "..os.date("%c", nota_build_date))
			print("Git commit: "..nota_git_info)
			os.exit(0)
		elseif opt == "f" then -- choose frontend
			module_frontend = arg
		end
	end
end

arg = {}
if nota_args[1] then
	applet = nota_args[1]
	local module_args = {}
	for nstr=2, nota_argsn do
		module_args[nstr-1] = nota_args[nstr]
	end
	arg = module_args
end

-- Storage: We use a database, because it simplifies search.
-- The choosen backend is QL, since it is written in Go and therefore doesn't spam OS threads like crazy. Plus it has compression and what not.
storagedb = assert(sql.open("ql", os.getenv("HOME").."/.nota.ql"))

-- SQL VFS
-- Since having a folder full of todo entries would be boring, we create a SQL vfs to store our shit.
assert(vfs.new("storage", "sql", storagedb, {
	tablename = "nota",
}))
vfs.searchpath("storage:/?.lua;storage:/?/init.lua;root:/?.lua;root:/?/init.lua")

-- Load frontend module and let it do its thing.
local suc, res = pcall(require, "frontend."..module_frontend)
if not suc then
	print("nota: Frontend module failed: "..res)
	storagedb:close()
	os.exit(1)
end
ui = res

-- Load applet which does all further interaction.
local exitstatus = 0
suc, res = pcall(require, "applets."..applet)
if not suc then
	print("nota: Failed loading applet "..applet..": "..res)
	exitstatus = 1
else
	exitstatus = tonumber(res) or 0
end
storagedb:close()
os.exit(exitstatus)
